// Code generated by ent, DO NOT EDIT.

package fnetdocument

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the fnetdocument type in the database.
	Label = "fnet_document"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldFnetID holds the string denoting the fnet_id field in the database.
	FieldFnetID = "fnet_id"
	// FieldAdditionalInformation holds the string denoting the additional_information field in the database.
	FieldAdditionalInformation = "additional_information"
	// FieldCategoryStr holds the string denoting the category_str field in the database.
	FieldCategoryStr = "category_str"
	// FieldFundDescription holds the string denoting the fund_description field in the database.
	FieldFundDescription = "fund_description"
	// FieldFundMarketName holds the string denoting the fund_market_name field in the database.
	FieldFundMarketName = "fund_market_name"
	// FieldHighPriority holds the string denoting the high_priority field in the database.
	FieldHighPriority = "high_priority"
	// FieldReferenceDate holds the string denoting the reference_date field in the database.
	FieldReferenceDate = "reference_date"
	// FieldReferenceDateFormat holds the string denoting the reference_date_format field in the database.
	FieldReferenceDateFormat = "reference_date_format"
	// FieldReferenceDateStr holds the string denoting the reference_date_str field in the database.
	FieldReferenceDateStr = "reference_date_str"
	// FieldReviewed holds the string denoting the reviewed field in the database.
	FieldReviewed = "reviewed"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldSubCategory1Str holds the string denoting the sub_category1_str field in the database.
	FieldSubCategory1Str = "sub_category1_str"
	// FieldSubCategory2Str holds the string denoting the sub_category2_str field in the database.
	FieldSubCategory2Str = "sub_category2_str"
	// FieldSubmissionDate holds the string denoting the submission_date field in the database.
	FieldSubmissionDate = "submission_date"
	// FieldSubmissionDateStr holds the string denoting the submission_date_str field in the database.
	FieldSubmissionDateStr = "submission_date_str"
	// FieldSubmissionMethod holds the string denoting the submission_method field in the database.
	FieldSubmissionMethod = "submission_method"
	// FieldSubmissionMethodDescription holds the string denoting the submission_method_description field in the database.
	FieldSubmissionMethodDescription = "submission_method_description"
	// FieldSubmissionStatus holds the string denoting the submission_status field in the database.
	FieldSubmissionStatus = "submission_status"
	// FieldSubmissionStatusDescription holds the string denoting the submission_status_description field in the database.
	FieldSubmissionStatusDescription = "submission_status_description"
	// FieldVersion holds the string denoting the version field in the database.
	FieldVersion = "version"
	// EdgeCategory holds the string denoting the category edge name in mutations.
	EdgeCategory = "category"
	// EdgeSubCategory1 holds the string denoting the sub_category1 edge name in mutations.
	EdgeSubCategory1 = "sub_category1"
	// EdgeSubCategory2 holds the string denoting the sub_category2 edge name in mutations.
	EdgeSubCategory2 = "sub_category2"
	// Table holds the table name of the fnetdocument in the database.
	Table = "fnet_documents"
	// CategoryTable is the table that holds the category relation/edge.
	CategoryTable = "fnet_documents"
	// CategoryInverseTable is the table name for the FnetCategory entity.
	// It exists in this package in order to avoid circular dependency with the "fnetcategory" package.
	CategoryInverseTable = "fnet_categories"
	// CategoryColumn is the table column denoting the category relation/edge.
	CategoryColumn = "category_id"
	// SubCategory1Table is the table that holds the sub_category1 relation/edge.
	SubCategory1Table = "fnet_documents"
	// SubCategory1InverseTable is the table name for the FnetSubCategory1 entity.
	// It exists in this package in order to avoid circular dependency with the "fnetsubcategory1" package.
	SubCategory1InverseTable = "fnet_sub_categories1"
	// SubCategory1Column is the table column denoting the sub_category1 relation/edge.
	SubCategory1Column = "sub_category1_id"
	// SubCategory2Table is the table that holds the sub_category2 relation/edge.
	SubCategory2Table = "fnet_documents"
	// SubCategory2InverseTable is the table name for the FnetSubCategory2 entity.
	// It exists in this package in order to avoid circular dependency with the "fnetsubcategory2" package.
	SubCategory2InverseTable = "fnet_sub_categories2"
	// SubCategory2Column is the table column denoting the sub_category2 relation/edge.
	SubCategory2Column = "sub_category2_id"
)

// Columns holds all SQL columns for fnetdocument fields.
var Columns = []string{
	FieldID,
	FieldFnetID,
	FieldAdditionalInformation,
	FieldCategoryStr,
	FieldFundDescription,
	FieldFundMarketName,
	FieldHighPriority,
	FieldReferenceDate,
	FieldReferenceDateFormat,
	FieldReferenceDateStr,
	FieldReviewed,
	FieldStatus,
	FieldSubCategory1Str,
	FieldSubCategory2Str,
	FieldSubmissionDate,
	FieldSubmissionDateStr,
	FieldSubmissionMethod,
	FieldSubmissionMethodDescription,
	FieldSubmissionStatus,
	FieldSubmissionStatusDescription,
	FieldVersion,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "fnet_documents"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"category_id",
	"sub_category1_id",
	"sub_category2_id",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// FnetIDValidator is a validator for the "fnet_id" field. It is called by the builders before save.
	FnetIDValidator func(int) error
	// CategoryStrValidator is a validator for the "category_str" field. It is called by the builders before save.
	CategoryStrValidator func(string) error
	// FundDescriptionValidator is a validator for the "fund_description" field. It is called by the builders before save.
	FundDescriptionValidator func(string) error
	// ReferenceDateFormatValidator is a validator for the "reference_date_format" field. It is called by the builders before save.
	ReferenceDateFormatValidator func(string) error
	// ReferenceDateStrValidator is a validator for the "reference_date_str" field. It is called by the builders before save.
	ReferenceDateStrValidator func(string) error
	// ReviewedValidator is a validator for the "reviewed" field. It is called by the builders before save.
	ReviewedValidator func(string) error
	// StatusValidator is a validator for the "status" field. It is called by the builders before save.
	StatusValidator func(string) error
	// SubmissionDateStrValidator is a validator for the "submission_date_str" field. It is called by the builders before save.
	SubmissionDateStrValidator func(string) error
	// SubmissionMethodValidator is a validator for the "submission_method" field. It is called by the builders before save.
	SubmissionMethodValidator func(string) error
	// SubmissionMethodDescriptionValidator is a validator for the "submission_method_description" field. It is called by the builders before save.
	SubmissionMethodDescriptionValidator func(string) error
	// SubmissionStatusValidator is a validator for the "submission_status" field. It is called by the builders before save.
	SubmissionStatusValidator func(string) error
	// SubmissionStatusDescriptionValidator is a validator for the "submission_status_description" field. It is called by the builders before save.
	SubmissionStatusDescriptionValidator func(string) error
	// VersionValidator is a validator for the "version" field. It is called by the builders before save.
	VersionValidator func(int) error
)

// OrderOption defines the ordering options for the FnetDocument queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByFnetID orders the results by the fnet_id field.
func ByFnetID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFnetID, opts...).ToFunc()
}

// ByAdditionalInformation orders the results by the additional_information field.
func ByAdditionalInformation(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAdditionalInformation, opts...).ToFunc()
}

// ByCategoryStr orders the results by the category_str field.
func ByCategoryStr(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCategoryStr, opts...).ToFunc()
}

// ByFundDescription orders the results by the fund_description field.
func ByFundDescription(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFundDescription, opts...).ToFunc()
}

// ByFundMarketName orders the results by the fund_market_name field.
func ByFundMarketName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFundMarketName, opts...).ToFunc()
}

// ByHighPriority orders the results by the high_priority field.
func ByHighPriority(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldHighPriority, opts...).ToFunc()
}

// ByReferenceDate orders the results by the reference_date field.
func ByReferenceDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReferenceDate, opts...).ToFunc()
}

// ByReferenceDateFormat orders the results by the reference_date_format field.
func ByReferenceDateFormat(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReferenceDateFormat, opts...).ToFunc()
}

// ByReferenceDateStr orders the results by the reference_date_str field.
func ByReferenceDateStr(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReferenceDateStr, opts...).ToFunc()
}

// ByReviewed orders the results by the reviewed field.
func ByReviewed(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReviewed, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// BySubCategory1Str orders the results by the sub_category1_str field.
func BySubCategory1Str(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubCategory1Str, opts...).ToFunc()
}

// BySubCategory2Str orders the results by the sub_category2_str field.
func BySubCategory2Str(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubCategory2Str, opts...).ToFunc()
}

// BySubmissionDate orders the results by the submission_date field.
func BySubmissionDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubmissionDate, opts...).ToFunc()
}

// BySubmissionDateStr orders the results by the submission_date_str field.
func BySubmissionDateStr(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubmissionDateStr, opts...).ToFunc()
}

// BySubmissionMethod orders the results by the submission_method field.
func BySubmissionMethod(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubmissionMethod, opts...).ToFunc()
}

// BySubmissionMethodDescription orders the results by the submission_method_description field.
func BySubmissionMethodDescription(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubmissionMethodDescription, opts...).ToFunc()
}

// BySubmissionStatus orders the results by the submission_status field.
func BySubmissionStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubmissionStatus, opts...).ToFunc()
}

// BySubmissionStatusDescription orders the results by the submission_status_description field.
func BySubmissionStatusDescription(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSubmissionStatusDescription, opts...).ToFunc()
}

// ByVersion orders the results by the version field.
func ByVersion(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldVersion, opts...).ToFunc()
}

// ByCategoryField orders the results by category field.
func ByCategoryField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCategoryStep(), sql.OrderByField(field, opts...))
	}
}

// BySubCategory1Field orders the results by sub_category1 field.
func BySubCategory1Field(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSubCategory1Step(), sql.OrderByField(field, opts...))
	}
}

// BySubCategory2Field orders the results by sub_category2 field.
func BySubCategory2Field(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSubCategory2Step(), sql.OrderByField(field, opts...))
	}
}
func newCategoryStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CategoryInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, CategoryTable, CategoryColumn),
	)
}
func newSubCategory1Step() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SubCategory1InverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, SubCategory1Table, SubCategory1Column),
	)
}
func newSubCategory2Step() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SubCategory2InverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, SubCategory2Table, SubCategory2Column),
	)
}
